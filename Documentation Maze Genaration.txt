Documentation Maze Genaration:

<1> Firtsly, we needed a cell class, a blueprint for each cell, containing details about:
	1. the cell walls: Dictionary for each wall and whether it exists or not (ex: 			"top":True)
	2. cell coordinates: column and row/ x and y
	3. Visited: whether a cell is visited or not (True/False)
	4. Neighbors: the adjacency list of neighboring cells
The cell objects are gonna be used to generate a grid of cells, which will be processed to create a pattern of a maze and then be rendered using pygame

<2> The MazeGenerator class is then created to store a collection of cell objects, creating a grid as a base for the maze.
The MazeGenerator class is initialized by receiving the desired size of the maze/grid, and generating a grid (2D list ) of cell objects, as well as initializing the grid by generating the adjacency list of each cell ("neighbors[]"), and opening the beginning wall of the top left cell. The class includes several methods to create the maze. 
	1. generateNeighbours: Uses a nested loop to traverse the 2D array "grid". 
		Checks whether a cell has neighboring cells in each direction by calculating the coordinates (x and y/indexes) of each neighboring cell and adding it to the adjacency list if 		it is within the bounds of the grid (Not out of bounds)
	2. removeWall: Receives the current cell and the past cell. Based on the difference 
		between the x and y coordinates of the cells, the direction of the current cell relative to the past cell can be determined, and the wall status 					(whether the wall exists or not) between the two cells is determined.
	3. DFS: Implements a basic iterative DFS algorithm using stack for maze generation with slight adjustments. Firstly, "pastCell" (initialized with None) is defined to be able to keep 		track of the past cell regardless of which next cell is chosen, to be able to remove the correct walls between cells using removeWall(cell,pastCell). Then we initialize a stack, as a list of pairs, each pair should store a cell and the cell that was before it (Elaborate on that more later). The first cell in the grid (top left), grid[0][0] is pushed on the empty stack, then we iterate as long as the stack is not empty. For each iteration, we pop a pair, and store the cell and the pastCell. If the cell was not visited before, we mark it as visited, so that it does not get visited again, and then we remove the wall between it and the previous cell "pastCell", and we iterate over the neighbours of the current cell (the adjacency list). As we iterate through each adjacent cell, we first add them  temporarily to a list, to be able to shuffle the neighbouring cells before being pushed onto the stack, this is done to ensure that the maze does not follow a basic organized flow. Then we append/push each neighbouring cell as a pair linking each of the cells with the current cell, so that later on, if the algorithm cannot find any unvisited neighbouring cells for a cell C, it shall back track till it reaches some unvisited neighbor cell A for some past cell B, however if we do not keep track of the cell A was a neighbor of, we wont be able to remove the correct wall between A and B, rather we would remove a wall between C and A (which is not a valid case because no such wall exists, )thats why we need to link each neighbouring cell to the cell that led to it.  
At the end of the method, the entire grid should be connected in a randomized way using DFS, then the bottom wall of the bottom right cell is removed to allow for an end opening for the maze.
<3> Thirdly, we implemented the GUI using pygame to be able to render the cells on the screen. We created an instance of the MazeGenerator class "maze" then called the method DFS() to update the walls of the cells in the grid in "maze" creating a pattern for the maze. We used the basic template for GUI provided in the pygame documentation. Then using the following methods, we were able to properly render the maze on the screen:
	1. drawCell(): The method receives the cell object and extracts its x and y coordinates, then simply draws lines for each walls if the wall is present.
	2.drawGrid(): Loops through the grid and for each cell, it calls drawCells(cell) to render it on the screen